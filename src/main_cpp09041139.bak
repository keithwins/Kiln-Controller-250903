// Uncomment to enable serial debug output (only when Serial Monitor is used)
// #define ENABLE_SERIAL_DEBUG

// Uncomment the line below if you have an MCP23017 for physical buttons
// #define USE_MCP23017

#include <Arduino.h>
#include <Adafruit_MAX31856.h>
#include <PID_v1.h>
#include <LovyanGFX.hpp>
#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <FS.h>
#include <SPIFFS.h>

// Display configuration for LovyanGFX
class LGFX : public lgfx::LGFX_Device
{
  lgfx::Panel_ST7796 _panel_instance;
  lgfx::Bus_SPI _bus_instance;
  lgfx::Touch_XPT2046 _touch_instance;

public:
  LGFX(void)
  {
    {
      auto cfg = _bus_instance.config();
      cfg.spi_host = VSPI_HOST;
      cfg.spi_mode = 0;
      cfg.freq_write = 40000000;
      cfg.freq_read = 16000000;
      cfg.spi_3wire = false;
      cfg.use_lock = true;
      cfg.dma_channel = SPI_DMA_CH_AUTO;
      cfg.pin_sclk = 18; // SCK
      cfg.pin_mosi = 23; // MOSI
      cfg.pin_miso = 19; // MISO (optional)
      cfg.pin_dc = 2;    // DC
      _bus_instance.config(cfg);
      _panel_instance.setBus(&_bus_instance);
    }

    {
      auto cfg = _panel_instance.config();
      cfg.pin_cs = 15;   // CS
      cfg.pin_rst = 4;   // RST
      cfg.pin_busy = -1; // Not used
      cfg.panel_width = 320;
      cfg.panel_height = 480;
      cfg.offset_x = 0;
      cfg.offset_y = 0;
      cfg.readable = true;
      cfg.invert = false;
      cfg.rgb_order = false;
      cfg.dlen_16bit = false;
      cfg.bus_shared = true;
      _panel_instance.config(cfg);
    }

    {
      auto cfg = _touch_instance.config();
      cfg.x_min = 0;
      cfg.x_max = 320;
      cfg.y_min = 0;
      cfg.y_max = 480;
      cfg.pin_cs = 5;    // Touch CS
      cfg.pin_int = -1;  // Use pin_int
      cfg.bus_shared = true;
      cfg.spi_host = VSPI_HOST;
      cfg.freq = 2500000;
      _touch_instance.config(cfg);
      _panel_instance.setTouch(&_touch_instance);
    }

    setPanel(&_panel_instance);
  }
};

LGFX display; // Keep only this declaration

// Uncomment this line to enable a dry run without the thermocouple
#define DRY_RUN

// WiFi credentials - change these!
const char *ssid PROGMEM = "wellbeing24_Guest";
const char *password PROGMEM = "wellbeing?25";

// --- Safety Limits ---
const double MAX_TEMPERATURE = 1200.0;
const double MIN_TEMPERATURE = 0.0;
const unsigned long MAX_HEATING_TIME = 14400000; // 4 hours max heating time (ms)

// --- Hardware Pin Definitions ---
const int MAX1_CS_PIN = 27; // First thermocouple
const int MAX2_CS_PIN = 26; // Second thermocouple
const int MAX_SCK_PIN = 18;
const int MAX_SO_PIN = 19;
const int MAX_SI_PIN = 23;

// SSR pins
const int SSR1_PIN = 32;
const int SSR2_PIN = 33;

// I2C pins
const int SDA_PIN = 32;
const int SCL_PIN = 25;

// --- Firing Schedule Structure ---
struct FiringSegment
{
  double targetTemp; // Target temperature for this segment
  int rampRate;      // Rate in Â°C/hour (0 = as fast as possible)
  int soakTime;      // Soak time in minutes
  bool completed;    // Has this segment been completed?
};

struct FiringSchedule
{
  char name[20];              // Fixed-size to avoid String
  FiringSegment segments[10]; // Max 10 segments
  int segmentCount;
  bool active;
  int currentSegment;
  unsigned long segmentStartTime;
};

// Predefined firing schedules
FiringSchedule presetSchedules[] = {
    {{"Bisque Fire"},
     {
         {200, 50, 30, false},  // Slow warm-up
         {500, 100, 60, false}, // Dehydration hold
         {950, 150, 20, false}, // Final bisque temp
     },
     3,
     false,
     0,
     0},
    {{"Glaze Fire"},
     {
         {300, 100, 0, false},  // Quick warm-up
         {600, 80, 0, false},   // Steady climb
         {1000, 60, 0, false},  // Approach glaze temp
         {1240, 30, 15, false}, // Glaze maturation
     },
     4,
     false,
     0,
     0},
    {{"Test Fire"},
     {
         {100, 60, 5, false},   // Gentle test
         {200, 120, 10, false}, // Hold
     },
     2,
     false,
     0,
     0}};

// --- Object Instantiation ---
Adafruit_MAX31856 maxsensor1(MAX1_CS_PIN, MAX_SI_PIN, MAX_SO_PIN, MAX_SCK_PIN);
Adafruit_MAX31856 maxsensor2(MAX2_CS_PIN, MAX_SI_PIN, MAX_SO_PIN, MAX_SCK_PIN);
AsyncWebServer server(80);

// --- PID Variables ---
double Setpoint, Input1, Input2, Output1, Output2;
double avgTemp;
PID myPID(&avgTemp, &Output1, &Setpoint, 50.0, 10.0, 5.0, DIRECT);

// --- System State Variables ---
bool systemEnabled = false;
bool emergencyStop = false;
bool wifiConnected = false;
unsigned long heatingStartTime = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastTempRead = 0;
unsigned long lastWiFiCheck = 0;

FiringSchedule currentSchedule;
bool usingSchedule = false;

// --- UI State ---
enum UIScreen
{
  SCREEN_MAIN,
  SCREEN_SCHEDULES,
  SCREEN_MANUAL,
  SCREEN_GRAPH,
  SCREEN_SETTINGS
};
UIScreen currentScreen = SCREEN_MAIN;

// --- Data logging ---
struct DataPoint
{
  unsigned long timestamp;
  double temp1, temp2, setpoint, output;
};

const int MAX_DATA_POINTS = 100;
DataPoint dataLog[MAX_DATA_POINTS];
int dataIndex = 0;
int validDataCount = 0;

// --- Touch handling ---
struct TouchArea
{
  int x, y, w, h;
  int id;
};

TouchArea touchAreas[20];
int touchAreaCount = 0;

// --- Colors ---
const uint32_t COLOR_BG = 0x1820;       // Dark blue
const uint32_t COLOR_CARD = 0x2945;     // Card background
const uint32_t COLOR_PRIMARY = 0x07E0;  // Green
const uint32_t COLOR_DANGER = 0xF800;   // Red
const uint32_t COLOR_WARNING = 0xFC00;  // Orange
const uint32_t COLOR_INFO = 0x07FF;     // Cyan
const uint32_t COLOR_TEXT = 0xFFFF;     // White
const uint32_t COLOR_TEXT_DIM = 0x8410; // Gray

#ifdef DRY_RUN
double fakedTemp1 = 22.0;
double fakedTemp2 = 23.0;
double ambientTemp = 22.0;
double thermalMass = 0.02;
double heatLoss = 0.98;
unsigned long lastTempUpdate = 0;
const int TEMP_UPDATE_INTERVAL = 200;
#endif

// Forward declarations
void drawBootScreen();
void displayError(const char *error);
void setupWiFi();
void setupWebServer();
void checkWiFi();
void drawMainScreen();
void readTemperatures();
void logData();
void handleTouch();
void handleFiringSchedule();
void performSafetyChecks();
void updateCurrentScreen();
void drawTemperatureCard(int x, int y, const char *label, double temp, uint32_t color);
void drawPowerBar(int x, int y);
void drawStatusArea(int x, int y);
void drawMainButtons();
void drawScheduleProgress(int x, int y);
void addTouchArea(int x, int y, int w, int h, int id);
void handleTouchAction(int actionId);
void drawManualScreen();
void drawSchedulesScreen();
void drawGraphScreen();
void drawSettingsScreen();

void setup()
{
  display.init();
  display.setRotation(0);
  display.setBrightness(128);

  pinMode(27, OUTPUT); // Backlight
  digitalWrite(27, HIGH);

  display.fillScreen(TFT_BLACK);
  display.setFont(&fonts::Font2);
  display.setTextColor(TFT_WHITE);
  display.drawString("ST7796S Test", 10, 10);
  display.drawString("If you see this, it works!", 10, 30);

  while (1) delay(1000); // Halt to keep message
}

void checkMemory()
{
  static unsigned long lastCheck = 0;
  if (millis() - lastCheck >= 10000) {
    lastCheck = millis();
    uint32_t freeHeap = ESP.getFreeHeap();
    uint32_t freePsram = ESP.getFreePsram();
    // Display on screen instead of Serial
    char memStr[32];
    snprintf(memStr, sizeof(memStr), "Heap: %u, PSRAM: %u", freeHeap, freePsram);
    display.setFont(&fonts::Font2);
    display.setTextColor(COLOR_TEXT);
    display.fillRect(10, 460, 300, 20, COLOR_BG);
    display.drawString(memStr, 10, 460);
  }
}

void loop()
{
  unsigned long currentTime = millis();

  // Read temperatures
  if (currentTime - lastTempRead >= 250)
  {
    lastTempRead = currentTime;
    readTemperatures();
    logData();
  }

  // Handle touch input
  handleTouch();

  // Handle firing schedule
  if (usingSchedule && currentSchedule.active)
  {
    handleFiringSchedule();
  }

  // Safety checks
  performSafetyChecks();

  // PID control
  if (systemEnabled && !emergencyStop)
  {
    avgTemp = (Input1 + Input2) / 2.0;
    myPID.Compute();
    int outputInt = (int)Output1;
    analogWrite(SSR1_PIN, outputInt);
    analogWrite(SSR2_PIN, outputInt);
  }
  else
  {
    digitalWrite(SSR1_PIN, LOW);
    digitalWrite(SSR2_PIN, LOW);
    Output1 = 0;
  }

  // Update display
  if (currentTime - lastDisplayUpdate >= 1000)
  {
    lastDisplayUpdate = currentTime;
    updateCurrentScreen();
  }

  // WiFi status check
  if (currentTime - lastWiFiCheck >= 5000)
  {
    lastWiFiCheck = currentTime;
    checkWiFi();
  }

  checkMemory();
  delay(10);
}

void setupWiFi()
{
  // Configure static IP to reduce DHCP delays
  IPAddress local_IP(192, 168, 1, 100);
  IPAddress gateway(192, 168, 1, 1);
  IPAddress subnet(255, 255, 255, 0);
  WiFi.config(local_IP, gateway, subnet);

  WiFi.begin(ssid, password);

  int attempts = 0;
  const int maxAttempts = 20; // 10 seconds total
  while (WiFi.status() != WL_CONNECTED && attempts < maxAttempts)
  {
    delay(500);
    attempts++;
  }

  wifiConnected = (WiFi.status() == WL_CONNECTED);
}

void checkWiFi()
{
  if (WiFi.status() != WL_CONNECTED)
  {
    wifiConnected = false;
    WiFi.reconnect();
    int attempts = 0;
    const int maxAttempts = 10; // 5 seconds
    while (WiFi.status() != WL_CONNECTED && attempts < maxAttempts)
    {
      delay(500);
      attempts++;
    }
    wifiConnected = (WiFi.status() == WL_CONNECTED);
  }
}

#include <FS.h>
#include <SPIFFS.h>

void setupWebServer()
{
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
            {
              request->send(200, "text/html", "<h1>Kiln Controller</h1><p>Server OK</p>");
            });

  server.on("/test", HTTP_GET, [](AsyncWebServerRequest *request)
            {
              request->send(200, "text/html", "<h1>Test Page</h1><p>Server is running!</p>");
            });

  server.begin();
}

void drawBootScreen()
{
  display.fillScreen(COLOR_BG);
  display.setFont(&fonts::Font4);
  display.setTextColor(COLOR_TEXT);
  display.drawString("KILN CONTROLLER", 20, 100);
  display.setFont(&fonts::Font2);
  display.drawString("Advanced Firing System", 50, 150);
  display.drawString("Initializing...", 100, 300);

#ifdef DRY_RUN
  display.setTextColor(COLOR_WARNING);
  display.drawString("** DRY RUN MODE **", 80, 250);
#endif
}

void drawMainScreen()
{
  static double lastInput1 = -999, lastInput2 = -999, lastSetpoint = -999, lastOutput = -999;
  static bool lastSystemEnabled = false, lastEmergencyStop = false, lastWifiConnected = false;

  if (lastInput1 == -999)
  {
    display.fillScreen(COLOR_BG);
    touchAreaCount = 0;

    display.setFont(&fonts::Font4);
    display.setTextColor(COLOR_TEXT);
    display.drawString("KILN STATUS", 60, 10);

    display.fillRoundRect(10, 60, 140, 60, 8, COLOR_CARD);
    display.drawRoundRect(10, 60, 140, 60, 8, COLOR_INFO);
    display.setFont(&fonts::Font2);
    display.setTextColor(COLOR_TEXT_DIM);
    display.drawString("TEMP 1", 20, 65);

    display.fillRoundRect(170, 60, 140, 60, 8, COLOR_CARD);
    display.drawRoundRect(170, 60, 140, 60, 8, COLOR_INFO);
    display.drawString("TEMP 2", 180, 65);

    display.fillRoundRect(10, 130, 140, 60, 8, COLOR_CARD);
    display.drawRoundRect(10, 130, 140, 60, 8, COLOR_PRIMARY);
    display.drawString("AVERAGE", 20, 135);

    display.fillRoundRect(170, 130, 140, 60, 8, COLOR_CARD);
    display.drawRoundRect(170, 130, 140, 60, 8, COLOR_WARNING);
    display.drawString("TARGET", 180, 135);

    display.setFont(&fonts::Font2);
    display.setTextColor(COLOR_TEXT);
    display.drawString("POWER OUTPUT", 10, 180);
    display.fillRoundRect(10, 200, 300, 25, 4, COLOR_CARD);

    display.drawString("STATUS:", 10, 240);
    display.drawString("WiFi:", 10, 260);

    drawMainButtons();
  }

  if (Input1 != lastInput1)
  {
    drawTemperatureCard(10, 60, "TEMP 1", Input1, COLOR_INFO);
    lastInput1 = Input1;
  }
  if (Input2 != lastInput2)
  {
    drawTemperatureCard(170, 60, "TEMP 2", Input2, COLOR_INFO);
    lastInput2 = Input2;
  }
  if (Input1 != lastInput1 || Input2 != lastInput2)
  {
    drawTemperatureCard(10, 130, "AVERAGE", (Input1 + Input2) / 2.0, COLOR_PRIMARY);
  }
  if (Setpoint != lastSetpoint)
  {
    drawTemperatureCard(170, 130, "TARGET", Setpoint, COLOR_WARNING);
    lastSetpoint = Setpoint;
  }
  if (Output1 != lastOutput)
  {
    drawPowerBar(10, 200);
    lastOutput = Output1;
  }
  if (systemEnabled != lastSystemEnabled || emergencyStop != lastEmergencyStop || wifiConnected != lastWifiConnected)
  {
    drawStatusArea(10, 240);
    lastSystemEnabled = systemEnabled;
    lastEmergencyStop = emergencyStop;
    lastWifiConnected = wifiConnected;
  }

  if (usingSchedule && currentSchedule.active)
  {
    drawScheduleProgress(10, 300);
  }
}

void drawTemperatureCard(int x, int y, const char *label, double temp, uint32_t color)
{
  display.setFont(&fonts::Font4);
  display.setTextColor(color);
  char tempStr[10];
  snprintf(tempStr, sizeof(tempStr), "%.1f C", temp);
  display.fillRect(x + 10, y + 25, 120, 30, COLOR_CARD);
  display.drawString(tempStr, x + 10, y + 25);
}

void drawPowerBar(int x, int y)
{
  int barWidth = 300;
  int barHeight = 25;

  int fillWidth = (int)((Output1 / 255.0) * barWidth);
  uint32_t fillColor = COLOR_PRIMARY;
  if (Output1 > 200)
    fillColor = COLOR_DANGER;
  else if (Output1 > 128)
    fillColor = COLOR_WARNING;

  display.fillRect(x, y, barWidth, barHeight, COLOR_CARD);
  if (fillWidth > 0)
  {
    display.fillRoundRect(x, y, fillWidth, barHeight, 4, fillColor);
  }

  char percentStr[6];
  snprintf(percentStr, sizeof(percentStr), "%.0f%%", (Output1 / 255.0) * 100);
  display.setTextColor(COLOR_TEXT);
  display.fillRect(x + barWidth + 10, y + 5, 50, 20, COLOR_BG);
  display.drawString(percentStr, x + barWidth + 10, y + 5);
}

void drawStatusArea(int x, int y)
{
  const char *statusText;
  uint32_t statusColor;

  if (emergencyStop)
  {
    statusText = "EMERGENCY STOP";
    statusColor = COLOR_DANGER;
  }
  else if (systemEnabled)
  {
    statusText = "HEATING";
    statusColor = COLOR_PRIMARY;
  }
  else
  {
    statusText = "READY";
    statusColor = COLOR_INFO;
  }

  display.setFont(&fonts::Font2);
  display.setTextColor(statusColor);
  display.fillRect(x + 80, y, 200, 20, COLOR_BG);
  display.drawString(statusText, x + 80, y);

  display.setTextColor(wifiConnected ? COLOR_PRIMARY : COLOR_DANGER);
  display.fillRect(x + 50, y + 20, 100, 20, COLOR_BG);
  display.drawString(wifiConnected ? "Connected" : "Disconnected", x + 50, y + 20);
}

void drawMainButtons()
{
  display.setFont(&fonts::Font2);
  display.setTextColor(COLOR_TEXT);

  addTouchArea(10, 360, 90, 40, 1);
  display.fillRoundRect(10, 360, 90, 40, 8, COLOR_INFO);
  display.drawString("MANUAL", 25, 375);

  addTouchArea(110, 360, 90, 40, 2);
  display.fillRoundRect(110, 360, 90, 40, 8, COLOR_PRIMARY);
  display.drawString("SCHEDULES", 118, 375);

  addTouchArea(210, 360, 100, 40, 3);
  uint32_t stopColor = emergencyStop ? COLOR_DANGER : 0x8000;
  display.fillRoundRect(210, 360, 100, 40, 8, stopColor);
  display.drawString("E-STOP", 235, 375);

  addTouchArea(10, 410, 90, 40, 4);
  display.fillRoundRect(10, 410, 90, 40, 8, COLOR_WARNING);
  display.drawString("GRAPH", 30, 425);

  addTouchArea(110, 410, 90, 40, 5);
  display.fillRoundRect(110, 410, 90, 40, 8, 0x4208);
  display.drawString("SETTINGS", 120, 425);

  if (emergencyStop)
  {
    addTouchArea(210, 410, 100, 40, 6);
    display.fillRoundRect(210, 410, 100, 40, 8, COLOR_PRIMARY);
    display.drawString("RESET", 240, 425);
  }
}

void drawScheduleProgress(int x, int y)
{
  display.fillRoundRect(x, y, 300, 50, 8, COLOR_CARD);
  display.setFont(&fonts::Font2);
  display.setTextColor(COLOR_TEXT);

  char nameStr[30];
  snprintf(nameStr, sizeof(nameStr), "SCHEDULE: %s", currentSchedule.name);
  display.drawString(nameStr, x + 10, y + 5);

  char segmentInfo[30];
  snprintf(segmentInfo, sizeof(segmentInfo), "Segment %d/%d: %.0f C",
           currentSchedule.currentSegment + 1, currentSchedule.segmentCount,
           currentSchedule.segments[currentSchedule.currentSegment].targetTemp);

  display.setTextColor(COLOR_TEXT_DIM);
  display.drawString(segmentInfo, x + 10, y + 25);
}

void addTouchArea(int x, int y, int w, int h, int id)
{
  if (touchAreaCount < 20)
  {
    touchAreas[touchAreaCount] = {x, y, w, h, id};
    touchAreaCount++;
  }
}

void handleTouch()
{
  static unsigned long lastTouch = 0;
  lgfx::touch_point_t tp;
  if (display.getTouch(&tp) && tp.size > 0 && millis() - lastTouch > 200)
  {
    lastTouch = millis();
    for (int i = 0; i < touchAreaCount; i++)
    {
      TouchArea &area = touchAreas[i];
      if (tp.x >= area.x && tp.x <= area.x + area.w &&
          tp.y >= area.y && tp.y <= area.y + area.h)
      {
        handleTouchAction(area.id);
        break;
      }
    }
  }
}

void handleTouchAction(int actionId)
{
  switch (currentScreen)
  {
  case SCREEN_MAIN:
    switch (actionId)
    {
    case 1:
      currentScreen = SCREEN_MANUAL;
      drawManualScreen();
      break;
    case 2:
      currentScreen = SCREEN_SCHEDULES;
      drawSchedulesScreen();
      break;
    case 3:
      emergencyStop = true;
      systemEnabled = false;
      drawMainScreen();
      break;
    case 4:
      currentScreen = SCREEN_GRAPH;
      drawGraphScreen();
      break;
    case 5:
      currentScreen = SCREEN_SETTINGS;
      drawSettingsScreen();
      break;
    case 6:
      if (!systemEnabled)
      {
        emergencyStop = false;
        drawMainScreen();
      }
      break;
    }
    break;
  case SCREEN_SCHEDULES:
    if (actionId >= 1 && actionId <= 3 && !systemEnabled)
    {
      currentSchedule = presetSchedules[actionId - 1];
      for (int i = 0; i < currentSchedule.segmentCount; i++)
      {
        currentSchedule.segments[i].completed = false;
      }
      currentSchedule.active = true;
      currentSchedule.currentSegment = 0;
      currentSchedule.segmentStartTime = millis();
      usingSchedule = true;
      systemEnabled = true;
      heatingStartTime = millis();
      currentScreen = SCREEN_MAIN;
      drawMainScreen();
    }
    else if (actionId == 4)
    {
      currentScreen = SCREEN_MAIN;
      drawMainScreen();
    }
    break;
  }
}

void readTemperatures()
{
#ifdef DRY_RUN
  if (millis() - lastTempUpdate >= TEMP_UPDATE_INTERVAL)
  {
    lastTempUpdate = millis();
    if (systemEnabled && !emergencyStop)
    {
      double heatInput = (Output1 / 255.0) * 15.0;
      fakedTemp1 = fakedTemp1 * heatLoss + (heatInput + ambientTemp) * thermalMass;
      fakedTemp2 = fakedTemp2 * heatLoss + (heatInput + ambientTemp) * thermalMass;
      fakedTemp1 += random(-20, 20) / 100.0;
      fakedTemp2 += random(-25, 25) / 100.0;
      fakedTemp1 = max(ambientTemp, min(1300.0, fakedTemp1));
      fakedTemp2 = max(ambientTemp, min(1300.0, fakedTemp2));
    }
    else
    {
      double coolingRate = 0.995;
      fakedTemp1 = fakedTemp1 * coolingRate + ambientTemp * (1 - coolingRate);
      fakedTemp2 = fakedTemp2 * coolingRate + ambientTemp * (1 - coolingRate);
      fakedTemp1 = max(ambientTemp, fakedTemp1);
      fakedTemp2 = max(ambientTemp, fakedTemp2);
    }
    Input1 = fakedTemp1;
    Input2 = fakedTemp2;
  }
#else
  Input1 = maxsensor1.readThermocoupleTemperature();
  Input2 = maxsensor2.readThermocoupleTemperature();

  uint8_t fault1 = maxsensor1.readFault();
  uint8_t fault2 = maxsensor2.readFault();
  if (fault1 || fault2)
  {
    emergencyStop = true;
    systemEnabled = false;
#ifdef ENABLE_SERIAL_DEBUG
    Serial.printf("Thermocouple fault - MAX1: 0x%02X, MAX2: 0x%02X\n", fault1, fault2);
#endif
  }
#endif
}

void logData()
{
  if (validDataCount < MAX_DATA_POINTS)
    validDataCount++;

  dataLog[dataIndex].timestamp = millis();
  dataLog[dataIndex].temp1 = Input1;
  dataLog[dataIndex].temp2 = Input2;
  dataLog[dataIndex].setpoint = Setpoint;
  dataLog[dataIndex].output = (Output1 / 255.0) * 100;

  dataIndex = (dataIndex + 1) % MAX_DATA_POINTS;
}

void handleFiringSchedule()
{
  if (!currentSchedule.active || currentSchedule.currentSegment >= currentSchedule.segmentCount)
  {
    currentSchedule.active = false;
    usingSchedule = false;
    systemEnabled = false;
    return;
  }

  FiringSegment &seg = currentSchedule.segments[currentSchedule.currentSegment];
  unsigned long elapsed = millis() - currentSchedule.segmentStartTime;

  if (seg.rampRate > 0)
  {
    double timeHours = elapsed / 3600000.0;
    double prevTemp = (currentSchedule.currentSegment == 0) ? 0.0 : currentSchedule.segments[currentSchedule.currentSegment - 1].targetTemp;
    double targetTemp = prevTemp + seg.rampRate * timeHours;
    if (targetTemp >= seg.targetTemp)
    {
      Setpoint = seg.targetTemp;
      if (seg.soakTime > 0)
      {
        unsigned long soakStart = currentSchedule.segmentStartTime + ((seg.targetTemp - prevTemp) * 3600000.0 / seg.rampRate);
        if (millis() - soakStart >= seg.soakTime * 60000UL)
        {
          seg.completed = true;
          currentSchedule.currentSegment++;
          currentSchedule.segmentStartTime = millis();
        }
      }
      else
      {
        seg.completed = true;
        currentSchedule.currentSegment++;
        currentSchedule.segmentStartTime = millis();
      }
    }
    else
    {
      Setpoint = targetTemp;
    }
  }
  else
  {
    Setpoint = seg.targetTemp;
    if (seg.soakTime > 0 && elapsed >= seg.soakTime * 60000UL)
    {
      seg.completed = true;
      currentSchedule.currentSegment++;
      currentSchedule.segmentStartTime = millis();
    }
  }
}

void performSafetyChecks()
{
  if (Input1 > MAX_TEMPERATURE || Input2 > MAX_TEMPERATURE)
  {
    emergencyStop = true;
    systemEnabled = false;
#ifdef ENABLE_SERIAL_DEBUG
    Serial.println("Over-temperature detected");
#endif
  }

  if (systemEnabled && (millis() - heatingStartTime > MAX_HEATING_TIME))
  {
    emergencyStop = true;
    systemEnabled = false;
#ifdef ENABLE_SERIAL_DEBUG
    Serial.println("Max heating time exceeded");
#endif
  }
}

void updateCurrentScreen()
{
  switch (currentScreen)
  {
  case SCREEN_MAIN:
    drawMainScreen();
    break;
  }
}

void drawManualScreen()
{
  // Placeholder for manual control screen
}

void drawSchedulesScreen()
{
  display.fillScreen(COLOR_BG);
  touchAreaCount = 0;

  display.setFont(&fonts::Font4);
  display.setTextColor(COLOR_TEXT);
  display.drawString("SCHEDULES", 40, 10);

  display.setFont(&fonts::Font2);
  for (int i = 0; i < 3; i++)
  {
    int y = 80 + i * 60;
    display.fillRoundRect(10, y, 280, 50, 8, COLOR_CARD);
    display.drawRoundRect(10, y, 280, 50, 8, COLOR_INFO);
    display.drawString(presetSchedules[i].name, 20, y + 15);
    char segments[20];
    snprintf(segments, sizeof(segments), "%d segments", presetSchedules[i].segmentCount);
    display.drawString(segments, 20, y + 35);
    addTouchArea(10, y, 280, 50, i + 1);
  }

  addTouchArea(10, 410, 90, 40, 4);
  display.fillRoundRect(10, 410, 90, 40, 8, COLOR_INFO);
  display.drawString("BACK", 30, 425);
}

void drawGraphScreen()
{
  // Placeholder for graph screen
}

void drawSettingsScreen()
{
  // Placeholder for settings screen
}

void displayError(const char *error)
{
  display.fillScreen(COLOR_DANGER);
  display.setFont(&fonts::Font4);
  display.setTextColor(COLOR_TEXT);
  display.drawString("ERROR", 100, 100);
  display.setFont(&fonts::Font2);
  display.drawString(error, 50, 150);
}